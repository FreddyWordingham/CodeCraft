# Paradigms

All programming languages are Turing complete, meaning they can be used to solve any problem that can be solved by a computer.
However, some languages are better suited to certain tasks than others.
This is because each language is designed with a specific paradigm in mind.

A programming paradigm is a style or way of thinking about programming.
It's not a specific language feature or syntax, but rather a way of approaching software design.
A paradigm is a set of rules and regulations that define how a programmer can build a program to solve a problem.

## Table of Contents

-   [Paradigms](#paradigms)
    -   [Table of Contents](#table-of-contents)
    -   [Procedural Programming](#procedural-programming)
    -   [Object-Oriented Programming (OOP)](#object-oriented-programming-oop)
    -   [Functional Programming](#functional-programming)
    -   [Logic Programming](#logic-programming)
    -   [Structured Programming](#structured-programming)
    -   [Imperative Programming](#imperative-programming)
    -   [Declarative Programming](#declarative-programming)
    -   [Concurrent Programming](#concurrent-programming)
    -   [Event-Driven Programming](#event-driven-programming)
    -   [Aspect-Oriented Programming (AOP)](#aspect-oriented-programming-aop)
    -   [Generic Programming](#generic-programming)
    -   [Reflective Programming](#reflective-programming)
    -   [Metaprogramming](#metaprogramming)

## Procedural Programming

Emerged in the 1950s.

Early Supporter: Fortran (1957). It was one of the first high-level languages to implement procedural programming, focusing on the procedure of the program.

## Object-Oriented Programming (OOP)

Emerged in the 1960s.

Early Supporter: Simula (1967). Often credited as the first language to offer object-oriented features like classes and objects.

## Functional Programming

Originated in the 1950s, but gained popularity in the 1970s.

Early Supporter: Lisp (1958). It's one of the earliest languages supporting functional programming, emphasizing functions and recursion.

## Logic Programming

Emerged in the 1970s.

Early Supporter: Prolog (1972). Introduced the paradigm of logic programming, focusing on formal logic.

## Structured Programming

Gained prominence in the late 1960s and early 1970s.

Early Supporter: ALGOL (1958). Influenced subsequent languages like C for structured programming, focusing on clear structure and blocks.

## Imperative Programming

Dates back to the earliest programming languages.

Early Supporter: Assembly languages and early high-level languages like Fortran and COBOL were imperative, focusing on how a program operates.

## Declarative Programming

Became more distinct as a paradigm in the 1970s.

Early Supporter: SQL (1974) for databases and Prolog for logic programming. These languages allow the programmer to express the logic without necessarily detailing the control flow.

## Concurrent Programming

Became more prominent in the 1970s and 1980s.

Early Supporter: Ada (1980). It was designed with built-in support for concurrent programming, including features for handling tasks, synchronization, and communication.

## Event-Driven Programming

Rose to prominence in the 1980s and 1990s.

Early Supporter: Visual Basic (1991) and other GUI-based languages. This paradigm is centered around the system responding to user or system-generated events.

## Aspect-Oriented Programming (AOP)

Emerged in the late 1990s.

Early Supporter: AspectJ (2001). An extension of Java, AspectJ was one of the first languages to support AOP, which allows separation of cross-cutting concerns.

## Generic Programming

Gained prominence in the 1990s.

Early Supporter: Ada and C++ (with templates introduced in 1989). This paradigm focuses on writing algorithms in terms of types to be specified later.

## Reflective Programming

Gained attention in the 1980s.

Early Supporter: Smalltalk (1980). One of the first languages to support reflection, allowing a program to manipulate the structure and behavior of the program itself.

## Metaprogramming

While the concept is older, it gained particular traction in the 1990s and 2000s.

Early Supporter: Lisp (with macros) and later Ruby and Python. This involves writing programs that write or manipulate other programs (or themselves).
